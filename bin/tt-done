#!/usr/bin/env python3
import os
import sys
import subprocess

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
REPO_ROOT = os.path.dirname(SCRIPT_DIR)
sys.path.insert(0, REPO_ROOT)

from common import load_threads_lines, save_threads_lines, mark_open_thread_done  # type: ignore

import re

def extract_description(content):
    # Match [**desc**](url) or **desc**
    m = re.match(r"\[\*\*(.*?)\*\*\]\([^)]+\)", content)
    if m:
        return m.group(1)
    m = re.match(r"\*\*(.*?)\*\*", content)
    if m:
        return m.group(1)
    return None

def get_open_threads(lines):
    open_indices = []
    open_tasks = []
    for i, line in enumerate(lines):
        if "- [ ]" in line:
            # Remove checkbox and timestamp for display
            content = line.strip()[5:].strip()
            if "<!--" in content:
                content = content[:content.index("<!--")].strip()
            elif "<!--" in content:
                content = content[:content.index("<!--")].strip()
            desc = extract_description(content)
            if desc:
                display = desc
            else:
                display = content
            open_indices.append(i)
            open_tasks.append(display)
    return open_indices, open_tasks

from typing import Optional

def prompt_for_done_task(open_tasks) -> Optional[str]:
    if not open_tasks:
        script = '''
        display dialog "No open tasks." buttons {"OK"} default button 1
        '''
        subprocess.run(["osascript", "-e", script])
        return None

    # Build the numbered list for display
    numbered = "\n".join(f"{i+1}. {task}" for i, task in enumerate(open_tasks))
    script = f'''
    display dialog "Mark which task as done?\\n\\n{numbered}\\n\\n(Enter number, or leave blank to cancel)" default answer "" buttons {{"OK", "Cancel"}} default button 1
    if button returned of result is "Cancel" then
        return "__CANCEL__"
    end if
    set userText to text returned of result
    return userText
    '''
    result = subprocess.run(
        ["osascript", "-e", script],
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        return None
    out = result.stdout.strip()
    if out == "__CANCEL__":
        return None
    return out

def main():
    lines = load_threads_lines()
    open_indices, open_tasks = get_open_threads(lines)

    user_input: Optional[str] = prompt_for_done_task(open_tasks)
    if user_input is None or user_input.strip() == "":
        # No input or user cancelled
        sys.exit(0)

    try:
        n = int(user_input)
    except ValueError:
        print("Input must be a number.")
        sys.exit(1)

    if n <= 0 or n > len(open_indices):
        print(f"Number must be between 1 and {len(open_indices)}.")
        sys.exit(1)

    new_lines, success = mark_open_thread_done(lines, n - 1)
    if not success:
        print(f"Could not mark thread #{n} as done (out of range?).")
        sys.exit(1)

    save_threads_lines(new_lines)
    # Reorder threads file after marking as done
    from common import reorder_threads_file  # type: ignore
    reorder_threads_file()
    print(f"Marked thread #{n} as done.")

if __name__ == "__main__":
    main()
