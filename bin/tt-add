#!/usr/bin/env python3
import os
import subprocess
from datetime import datetime

from pathlib import Path

# Ensure imports work when installed via symlink
import sys
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
REPO_ROOT = os.path.dirname(SCRIPT_DIR)
sys.path.insert(0, REPO_ROOT)

from common import ensure_threads_file_exists  # type: ignore

def get_front_app_and_title() -> tuple[str, str]:
    script = r'''
    tell application "System Events"
        set frontApp to name of first process whose frontmost is true
    end tell
    tell application frontApp
        if (count of windows) > 0 then
            set winTitle to name of front window
        else
            set winTitle to ""
        end if
    end tell
    return frontApp & "||" & winTitle
    '''
    result = subprocess.run(
        ["osascript", "-e", script],
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        return "unknown-app", ""
    raw = result.stdout.strip()
    if "||" in raw:
        app, title = raw.split("||", 1)
        return app.strip(), title.strip()
    return raw.strip() or "unknown-app", ""

def get_browser_url(app: str) -> str:
    # Returns the current tab URL for supported browsers, else ""
    if app == "Google Chrome":
        script = r'''
        tell application "Google Chrome"
            if (count of windows) > 0 and (count of tabs of front window) > 0 then
                return URL of active tab of front window
            else
                return ""
            end if
        end tell
        '''
    elif app == "Safari":
        script = r'''
        tell application "Safari"
            if (count of windows) > 0 and (count of tabs of front window) > 0 then
                return URL of current tab of front window
            else
                return ""
            end if
        end tell
        '''
    elif app == "Arc":
        script = r'''
        tell application "Arc"
            if (count of windows) > 0 and (count of tabs of front window) > 0 then
                return URL of active tab of front window
            else
                return ""
            end if
        end tell
        '''
    else:
        return ""
    result = subprocess.run(
        ["osascript", "-e", script],
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        return ""
    return result.stdout.strip()

def prompt_description() -> str:
    script = r'''
    display dialog "Thread description (optional):" default answer "" buttons {"OK"} default button 1
    set userText to text returned of result
    return userText
    '''
    result = subprocess.run(
        ["osascript", "-e", script],
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        return ""
    return result.stdout.strip()

def main():
    threads_file = ensure_threads_file_exists()
    app, title = get_front_app_and_title()
    desc = prompt_description()

    url = ""
    if app in {"Google Chrome", "Safari", "Arc"}:
        url = get_browser_url(app)

    # Place desc at the beginning, and make it clickable if it's a link or if url is present
    parts = []

    def is_url(s: str) -> bool:
        return s.startswith("http://") or s.startswith("https://")

    desc_part = ""
    if desc:
        if is_url(desc):
            # desc is a URL, make it a clickable bolded link to itself
            desc_part = f"[**{desc}**]({desc})"
        elif url:
            # desc is not a URL, but we have a url, make desc clickable to url
            desc_part = f"[**{desc}**]({url})"
        else:
            # just bold the desc
            desc_part = f"**{desc}**"

    if desc_part:
        parts.append(desc_part)
    if app:
        parts.append(app)
    if title:
        parts.append(title)

    summary = " â€” ".join([p for p in parts if p])

    # No need to append url at the end, it's included in the clickable desc if present

    if not summary:
        summary = "Unnamed thread"

    timestamp = datetime.now().isoformat(timespec="seconds")
    entry = f"- [ ] {summary}  <!-- {timestamp} -->\n"

    with open(threads_file, "a", encoding="utf-8") as f:
        f.write(entry)

    # Reorder threads file after adding
    from common import reorder_threads_file  # type: ignore
    reorder_threads_file()

    print(f"Added thread:\n  {summary}")
    print(f"Stored in: {threads_file}")

if __name__ == "__main__":
    main()
